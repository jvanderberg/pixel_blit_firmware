# Prototype Summary

## cblinken — Parallel WS2812/WS2811 Engine
- **Purpose**: Drive up to 16 WS281x strings per board (and multiple daisy-chained boards) from a Pi Pico/RP2350 using one PIO state machine and DMA-fed bitplanes. Includes experiments for raster mapping, color utilities, and IR remote control.
- **Key files**:
  - `cblinken/pixelblit.c`: Demo application that builds visual patterns (rainbow, sparkle, shooting star, diagnostics) on top of the library APIs and shows how scheduled animations and multicore helpers will be layered in.
  - `cblinken/lib/libpixelblit.c`: Core driver. Compiles the custom `ws2812_parallel` PIO program, sets up the dual DMA channels (0 for pixel bitplane bursts, 1 as a control-block feeder), and double-buffers `value_bits_t` arrays so frames can be prepared while the previous one shifts out. Also encodes board IDs as a preamble so each board in the chain can keep its data.
  - `cblinken/lib/utils.c/.h`: Raster object management. Builds arbitrary height×width rasters that map to the physical strips with wrap/clip modes, includes the fixed-point Gaussian “bin” weights used for sub-pixel blending, palette helpers, fade/rainbow utilities, and the façade for shifting rasters with interpolation.
  - `cblinken/ws2812.pio`: Two PIO programs—a single-pin reference and the custom parallel variant that emits 32-bit words where each bit plane maps to one of the STRIPS outputs. Timing constants (T1/T2/T3) are tuned for 800 kHz WS2811/WS2812 signaling.
  - `cblinken/ir_control.c/.h`: NEC-style IR receiver prototype. Uses GPIO IRQ falling edges, measures the space lengths to reconstruct 32-bit frames, validates inverse bytes, and enqueues button codes for the main loop. Handler stubs still contain TODOs for tying the buttons into animations or settings.
  - `cblinken/test.c`: CPU-side harness for verifying the Gaussian/bin math and raster shifting without hardware; uses the same helper APIs with `LOCAL_TESTING` types.
- **Notable behaviors**: compile-time `LOCAL_BUILD` gates the size constants (e.g., 16 strips × 75 px when running on the host), `value_bits_t buffers[2][BOARDS][NUM_PIXELS*3]` implements the double buffering, DMA completion ISR enforces the WS2812 reset time before allowing the next frame, and raster creation verbose logging documents the physical mapping for debugging. IR support currently only queues codes; higher-level reactions remain TODOs.

## board address prototype — Analog DIP decode
- **Purpose**: Validate the analog-resistor ladder scheme that encodes a 4-bit board address onto a single ADC pin of the RP2350.
- **Implementation**: `board address prototype/temp_board_address.c` configures GPIO47 as ADC7, averages 100 samples, and compares against the precomputed 12-bit codebook (`level_codes`). The `code_by_rank` lookup converts the sorted voltage ranks back into the DIP bit pattern. Prints the raw ADC reading, nearest code, error margin, and decoded address once per second to confirm there is enough headroom between adjacent switch settings.
- **Status/Gaps**: Designed for the specific pull-up/pull-down network described in the top-level README (47 kΩ pull-up, 47/100/220/470 kΩ legs). Any hardware tolerance tweaks mean re-generating the `level_codes`. Debouncing/integration with the rest of the firmware has not been added yet.

## lvds — High-speed inter-board link
- **Purpose**: Prototype the LVDS “string of boards” transport: board 0 acts as the root sender streaming framed 32-bit words, downstream boards recover them over a 4-wire LVDS link (3 data + clock) using PIO, DMA, and multicore buffering.
- **Key files**:
  - `lvds/blink.c`: Master test application. Compile-time switch selects `PARALLEL_SENDER` vs `PARALLEL_RECEIVER` (receiver is currently enabled). TX mode packetizes bytes into 32-bit words with the top two bits acting as headers (`00` board, `01` string, `10` pixel payload, `11` sync). RX mode oversamples the incoming pins 4× in the `parallel_in` PIO, then hands the stream to the `board_filter` PIO (second SM) which discards boards that do not match `BOARD_ID`. DMA channel 0 shuttles raw samples into the filter SM, DMA channel 2 double-buffers the filtered payload into RAM, and core 1 drains/validates buffers via the FIFO. The main loop tracks Mbps, interrupt overruns, and verifies the received “Hello, World” payload.
  - `lvds/parallel_out.pio`: Sender-side program. Uses sideset for the clock line and shifts out 3 data bits per PIO instruction, inserting an idle low/high preamble and a final sync.
  - `lvds/parallel_in.pio`: Receiver-side program. Waits for the clock edges, delays to the middle of the eye, and samples 3-bit chunks repeatedly before grabbing the last 2 bits; designed for an oversample/decimate approach that tolerates skew.
  - `lvds/board_filter.pio`: Stateful parser that consumes the word stream, watches for `00` headers, compares the following board ID against the OSR-seeded value, and only pushes matching records (string/pixel words) into RX FIFO 1.
  - `lvds/vcocalc.py`: PLL helper to compute clock settings (REFDIV/FBDIV/POSTDIV) for the custom 360 MHz overclock used by the prototype; prints ready-to-paste CMake definitions.
- **Notable behaviors/next steps**: Multiple DMA IRQ handlers (one per channel) keep the PIO FIFOs serviced and flip between the two 1 KiB buffers. `proto/` holds a recursive snapshot of the same experiments for quick cloning, but no code changes compared to the parent. Framing currently repeats ASCII test data; real pixel packets still need CRCs/error reporting and integration with the pixel DMA pipeline.
